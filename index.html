<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Your Portfolio</title>
  <link rel="stylesheet" href="styles.css">
</head>
<body>

    <ul class="menu" id="menu">
        <li><a href="#section1">Signal Processing</a></li>
        <li><a href="#section2">Control Systems</a></li>
        <li><a href="#section3">FPGA</a></li>
        <li><a href="#section4">Circuit Design/Spice Simulation</a></li>
    </ul>
    <header>
     
        <div class="header-content">
            <div class="header-buttons">
                <a href="aboutme.html" class="about-btn">About Me</a>
                <a href="#portfolio" class="portfolio-btn">Portfolio</a>
            </div>
            <h1>Engineering Portfolio</h1>
            <p>Welcome to my portfolio showcase</p>
        </div>
    </header>

    <div class="container" id="section1">

        <div class="project">
            <h2>Signal Processing</h2>
            <div class="project-image" id="project1">
                <img src="graphs/Digital_To_Analog.jpg" alt="Digital to Analog" width="300">
            </div>
            <div class="project-details">
                <p> This project explores the process of converting digital signals to analog using a filtered Butterworth low-pass filter. It involves converting discrete data points to a smooth sine wave, mimicking the process of digital-to-analog conversion. Digital-to-analog conversion is crucial in various applications such as audio processing, telecommunications, and control systems. It plays a significant role in microprocessing, enabling communication between digital systems and the physical world.</p>
            </div>
        </div>
        <div class="container" id="section2">
            <div class="project">
                <h2>Control Systems</h2>
                <div class="project-image" id="project2">
                    <img src="graphs/PID.jpg" alt="Project 2">
                </div>
                <div class="project-details">
                    <p>
                        This project showcases the implementation of a control system loop in a robotic arm to maintain a specific position. Initially developed using first robotics libraries in Java, the code was adapted for operation in C, necessitating reverse engineering and modification to suit language constraints.
                    </p>
                    <p>
                        The robotic arm, equipped with an optical shaft encoder, required a conversion process from encoder revolutions to voltage levels corresponding to degrees. Critical to this process were the encoder's resolution data, defining voltage levels for specific angles: approximately 1.8 volts for 90 degrees (up position), 0.75 volts for 45 degrees (down position), and 0.2 volts for 20 degrees (ground position).
                    </p>
                    <p>
                        To achieve precise positional control, a Proportional-Integral-Derivative (PID) control loop was employed. Initially exhibiting overshooting, iterative adjustments were made to the Proportional (P) and Integral (I) coefficients to attain a balanced system response. The provided code includes configurations for sensors, motors, and constants essential for project operation. Through PID control integration and parameter calibration, the robotic arm demonstrates precise positional control, exemplifying the efficacy of control systems in practical applications.
                    </p>
                    <div class="source-code">
                        <h3>Source Code - C</h3>
                        <pre><code class="language-c">
    /*	Open - Source
        Engineer - Nicholas Calamuso
        2018
    */


    #pragma config(Sensor, in1,    armPot,         sensorPotentiometer)
    #pragma config(Sensor, dgtl7,  leftenc,        sensorQuadEncoder)
    #pragma config(Sensor, dgtl9,  rightenc,       sensorQuadEncoder)
    #pragma config(Motor,  port1,           leftmotor,     tmotorVex393_HBridge, openLoop, reversed)
    #pragma config(Motor,  port2,           arm,           tmotorVex393_MC29, openLoop)
    #pragma config(Motor,  port9,           claw,          tmotorVex393_MC29, openLoop)
    #pragma config(Motor,  port10,          rightmotor,    tmotorVex393_HBridge, openLoop)
    //*!!Code automatically generated by 'ROBOTC' configuration wizard !!*//

    // Define constants
    #define PID_Motor_Max       127
    #define PID_Motor_Min       (-127)
    #define PID_INTEGRAL_LIMIT  50

    // Global variables
    bool teleop;
    int iterate;
    bool pidRunning;

    // Function to control arm movement using a PI controller
    void armControl(float target, float kP, float kI) {
    float error;
    float Integral = 0;
    float motorPower;

    while (true) {
    if (pidRunning) {
    if (iterate < 1) {
    SensorValue[armPot] = 1; // Initialize sensor if not yet done
    }
    error = SensorValue[armPot] - target;

    // Integral component
    if (kI != 0) {
    if (fabs(error) < PID_INTEGRAL_LIMIT)
    Integral += error;
    else
    Integral = 0;
    }
    else
    Integral = 0;

    // Calculate motor power using PI control
    motorPower = (kP * error) + (kI * Integral);

    // Limit motor power within specified range
    if (motorPower > PID_Motor_Max)
    motorPower = PID_Motor_Max;
    else if (motorPower < 5 && motorPower > -5) // Apply deadband
    motorPower = 0;
    else if (motorPower < PID_Motor_Min)
    motorPower = PID_Motor_Min;

    // Set motor output
    motor[arm] = motorPower;

    iterate = 1; // Flag that iteration has occurred
    }
    else {
    // Clear all values and stop motor if PID is not running
    error = 0;
    Integral = 0;
    motor[arm] = 0;
    }
    // Run loop at 50 Hz
    wait1Msec(25);
    }
    }

    // Tasks for different arm movements
    task armUp() {
    armControl(up, 0.3, 0.5); // Move arm up with specified parameters
    }

    task armGround() {
    armControl(ground, 0.3, 0.5); // Move arm to ground position
    }

    task armDown() {
    armControl(down, 0.4, 0.5); // Move arm down with specified parameters
    }

    // Task for controlling drive motors
    task drive() {
    // Control drive motors based on joystick input
    motor[leftmotor] = -vexRT[Ch3] - 20;
    motor[rightmotor] = -vexRT[Ch2] - 20;
    }

    // Function to convert inches to encoder ticks
    float distance(float inches) {
    float ticks = (90 / 13) * inches; // Assuming gear ratio and wheel diameter
    return ticks;
    }

    // Reset encoder values
    void resetEncoders() {
    SensorValue[leftenc] = 0;
    SensorValue[rightenc] = 0;
    }

    // Main task
    task main() {
    // Initialize variables
    teleop = true;
    up = 1600;    // 90 degree angle
    down = 750;   // 45 degree angle
    ground = 200; // 20 degree angle
    pidRunning = true;

    // Main teleop loop
    while (teleop) {
    // Start drive task
    startTask(drive);

    // Arm control based on button inputs
    if (vexRT[Btn6D] && !vexRT[Btn6U]) {
    iterate = 0;
    startTask(armDown);
    stopTask(armUp);
    stopTask(armGround);
    }

    if (vexRT[Btn6U] && !vexRT[Btn6D]) {
    startTask(armUp);
    stopTask(armDown);
    stopTask(armGround);
    }

    if (vexRT[Btn6D] && vexRT[Btn6U]) {
    iterate = 0;
    stopTask(armUp);
    stopTask(armDown);
    startTask(armGround);
    }

    // Control claw based on button inputs
    if (vexRT[Btn5D] == 1)
    motor[claw] = 127;
    else if (vexRT[Btn5U] == 1)
    motor[claw] = -127;
    else
    motor[claw] = 0;
    }
    }
</code></pre>
                    </div>
                </div>
                <div class="container" id="section3">
                    <div class="project">
                        <h2>FPGA</h2>
                        <div class="project-image" id="project3">
                            <img src="Graphs/Xilinx1.jpg" alt="Project 3">
                        </div>
                        <div class="project-image" id="project3">
                            <img src="Graphs/Xilinx2.jpg" alt="Project 3 Image 2">
                        </div>
                        <div class="project-details">
                            <p>This project revolves around implementing a clock divider on the Nexys3 development board using Xilinx Vivado and VHDL. The functionality of the project entails the 100MHz clock being fed into the FPGA, which then generates a 4MHz clock. The clock divider subsequently divides the 4MHz signal, and the binary counter counts cycles, displaying the count on LEDs. The counter resets upon reaching its maximum count (1111). Extensive testbench simulations were conducted to verify correct operation, ensuring accurate binary counting and reset functionality. Overall, this project offers valuable insights into digital design and clock management within FPGA environments.</p>
                        </div>
                        <div class="source-code">
                            <h3>Source Code - VHDL</h3>
                            <pre><code class="language-c">
    /*
        Open-Source
        Engineer - Nicholas Calamuso
        2021
    */
    ----------------------------------------------------------------------------------
    library IEEE;
    use IEEE.STD_LOGIC_1164.ALL;
    use IEEE.NUMERIC_STD.ALL;

    entity CLK_DIVIDER_TOP is
    Port ( CLK_100MHZ_IN : in  STD_LOGIC;
    LED_TP_OUT : out  STD_LOGIC;
    CNT_LED_OUT : out  STD_LOGIC_VECTOR (3 downto 0)
    );
    end CLK_DIVIDER_TOP;

    architecture Behavioral of CLK_DIVIDER_TOP is

    component CLK_GEN
    port
    (-- Clock in ports
    CLK_IN1           : in     std_logic;
    -- Clock out ports
    CLK_OUT1          : out    std_logic;
    -- Status and control signals
    RESET             : in     std_logic;
    LOCKED            : out    std_logic
    );
    end component;

    constant CNT_MAX 	: integer := 4E6;

    signal clk_div_cnt 	: integer range 0 to CNT_MAX-1 := 0;
    signal clk_div_cnt_tc 	: std_logic := '0'; -- terminal count
    signal clk_4mhz 	: std_logic; -- DCM 4MHz clock output
    signal binary_cnt 	: integer range 0 to 15 := 0;
    signal binary_cnt_slv 	: std_logic_vector(3 downto 0);

    begin

    clk_gen_inst : CLK_GEN
    port map
    (-- Clock in ports
    CLK_IN1 => CLK_100MHZ_IN,
    -- Clock out ports
    CLK_OUT1 => clk_4mhz,
    -- Status and control signals
    RESET  => '0',
    LOCKED => open
    );



    clk_div: process(clk_4mhz)
    begin
    if rising_edge(clk_4mhz) then
    if (clk_div_cnt < CNT_MAX-1  ) then
    clk_div_cnt <= clk_div_cnt + 1; -- count
    clk_div_cnt_tc <= '0';
    else
    clk_div_cnt <= clk_div_cnt +1 ;
    clk_div_cnt_tc <= '1';
    end if;
    end if;
    end process;

    binary_cntr_inst: process(clk_4mhz)
    begin
    if rising_edge(clk_4mhz) then
    if clk_div_cnt_tc = '1' then
    if (binary_cnt < 15) then
    binary_cnt <= binary_cnt + 1;
    else
    binary_cnt <= 0;
    end if;
    end if;
    end if;
    end process;

    -- convert integer to std_logic_vector
    binary_cnt_slv <= std_logic_vector(to_unsigned(binary_cnt, binary_cnt_slv'length));
    -- output lsb of binary counter to the test LED
    LED_TP_OUT <= binary_cnt_slv(0);


    -- convert the binary count integer to std_logic_vector to output to LEDs
    CNT_LED_OUT <= std_logic_vector(to_unsigned(binary_cnt , CNT_LED_OUT'length));


    end Behavioral;

</code></pre>
                        </div>
                    </div>
                    <section id="section4">
                        <h2>Circuit Design/Spice Simulation</h2>

                        <div class="project">
               
                            <div class="project-image" id="project4_1">
                                <img src="Graphs/fullspice.jpg" alt="Project 1">
                            </div>
                            <div class="project-details">
                                <p>
                                    In this project, the focus is on designing an AC to DC converter while utilizing SPICE simulation, specifically LTspice. The input signal originates from a 120Vrms wall source operating at a frequency of 60 Hz. This alternating current undergoes transformation via a transformer before passing through a bridge rectifier, which rectifies the AC signal into DC. Subsequently, the rectified signal is filtered by a capacitor to reduce ripple, then regulated by a zener diode to stabilize the voltage. Finally, the DC output voltage is supplied to a resistive load.

                                    The project entails comprehensive analysis through SPICE simulation, visualizing various waveforms and parameters critical to converter performance. Key components of interest include the AC input waveform, showcasing the characteristics of the incoming signal. Additionally, the ripple current across the capacitor provides insight into the effectiveness of filtering, crucial for maintaining stable output voltage. Finally, the graph illustrating the DC output voltage offers an overview of the converter's ability to provide consistent and reliable power to the load.
                                </p>
                            </div>
                        </div>

               


                </div>

                <div class="modal" id="modal">
                    <span class="close" id="close">&times;</span>
                    <img class="modal-content" id="modal-img">
                </div>

                <script src="script.js" defer></script>
</body>
</html>
